# Proposed Project Directory Structure

The `btcmesh` project will be organized within the `lora/` directory as follows:

```
lora/
└── btcmesh/
    ├── btcmesh_cli.py         # Client script for sending transactions
    ├── btcmesh_server.py      # Server/Relay script for processing transactions
    ├── core/                  # Core logic for the server/relay
    │   ├── __init__.py
    │   ├── config_loader.py   # For loading config.ini
    │   ├── logger_setup.py    # For setting up consistent logging
    │   ├── transaction_parser.py # For decoding raw Bitcoin transactions
    │   ├── rpc_client.py      # For interacting with Bitcoin RPC
    │   └── reassembler.py     # For reassembling chunked messages
    ├── project/               # Project planning documents (this file, reference_materials.md)
    │   ├── tasks.txt
    │   └── reference_materials.md
    ├── logs/                  # Directory for log files (created at runtime)
    │   └── btcmesh_server.log
    │   └── btcmesh_cli.log    # If btcmesh_cli.py also implements file logging
    ├── tests/                 # Unit and integration tests
    │   ├── __init__.py
    │   ├── test_config_loader.py
    │   ├── test_transaction_parser.py
    │   ├── test_rpc_client.py
    │   ├── test_reassembler.py
    │   ├── test_btcmesh_cli.py
    │   └── test_btcmesh_server.py
    ├── config.ini.example     # Example configuration file for the server
    └── README.md              # Project README describing setup, usage, etc.
```

# Raw Transaction example
02000000000108bf2c7da5efaf2708170ffbafde7b2b0ca68234474ea71d443aee6aebfbf998030000000000fdffffffd6fcdbf37f974be27e8b0d66638355e5f53bfaf7b930fae035d23b313c4751042900000000fdffffffcccc5ca913b8eb426fd7c6bb578eab0f26583d40c51ce52cb12a428c1e75f7320100000000fdffffff981b8b54ad2a8bd8b59d063e9473aead87412b699cb969298cf29b8787fe10600000000000fdffffff5d154c445b35a92aaf179c078cdab6310e69455cde650f128cbe85d92bab51600100000000fdffffff7d23c74a412ef33d5dd856d01933dd6a5453aee3539b12349febbf6c1ba157980100000000fdffffffc5c95ce2eac84fbd3db87bbbdb4cc0855088e891cc57b1f9e0684943a399aabf0000000000fdffffffb7ef5d8a55141068da0d7b5a712ad9bbe44c3b8b412d0df5b9bcad366d71c8f90500000000fdffffff01697c63030000000016001482ea8436a6318c989767a51ce33886d65faf59a10247304402203ec9cfb2b60a7b1df545493d1794fec0b8b6d8589f562f61c9aec6852775b54102205dfb34dcc9cc31110fdf4e4544c76e9a664cf29e8f1f9905771db386882527190121030e92cc6f0829ea8b91469c8aa7ca0660d66020d3e8baaece478905e0c30c1f770247304402204a3a6a7a5d4ff285b1ba4a3457dae8566a1616738f94e9eddcce6a75dbb831ef0220285c586f6463dcf68ccef59484b2d12bccd7d68a68b7092068e6cbfd96f04d88012102f48b8ab9a082a1cf94dcd7052ddea7d260b40cf01e83aa3df00f2266721ef420024730440220527c3eb66a06d697a078b2b2bdf9be52f9fe036b1e3422a0a150e151ff0cd25b0220268688d8d9a3dd24b9f846b1b2f1b1f1ed84443f0023e26fa1ac5f2c1f0626ac012103acc2fbe36c425eb49389e5896232ef90beda75531845cd726dfed5f60a1fedd10247304402202eee600a307d10fc4777e8143d3db8994a6e742d56d4e3ce67a21a1e5e509178022022ee1b1fee5d7ec8112a56b1c0ab2eef1be00907d384bbf10a7a9d2d27564fb5012103bd6876311fbf657af0c1c85e907c3adf8d5086d1b3cf2cd4805b40873d2cf3cd02473044022042dbc6204b70da1548456beef504d5e8d61349dd36913832060b35f61a360429022006940b48cff72f6476b8d4495126618766500f0868fb99ba40ab518934e9cc2b0121035aa46c0cf9b30a9edf20c65e5c39158aefbfdd2b7a049d146f42b7dc3163d1b50247304402207811bd5b127e8a693f20115f7f8b8b4dec6a4d5df32109b21e1252331778ac5202202ac727cc6c53287110fcd371845b5fcdba825cb9e60992cc01cffa8e2ee41701012102700455a96ddb63fdaf8fc3ad60d02b057f8e00ed512476d817150a22fd4495d90247304402202caf8f9c584fe1b5214dc2a67f42fe3b9fd7386b98807fc6bc273a2cf519769902201f9f7b407f92c7df84701e4259acb198ca19c5edbd860385caa6ca1316417c010121035bfcbb577fe3a3a805c78226c7e7c573053e85e6641243c8f435acde0e04668902473044022074d6273ed2c7f338c9db6a979f64f572a21e5a324eec4979dad77383b25263de02202635d0e21ddf4e46f5751d4d6117ad559f04b7a6d3d00f13dd784b82a902638e012103de05dcec6736d4e15dd88c5b34b638fee6cccfd8b260d53379a43be0b343617cd9540c00

---

# EPIC: Bitcoin Transaction Relay over LoRa Meshtastic

**Goal:** To enable users to broadcast Bitcoin raw transactions by sending them as **chunked hexadecimal strings** via a LoRa Meshtastic direct message, using a dedicated client script (`btcmesh-cli.py`). The relay device (`btcmesh-server.py`) will reassemble these chunks, decode, validate, and then relay the complete transaction to a configured Bitcoin RPC node.

**User Persona:** A Bitcoin user who wants to broadcast a raw transaction using a command-line tool (`btcmesh-cli.py`), potentially in an environment with limited or censored internet access, but with LoRa Meshtastic network availability.

---

## Stories

> **Note:** This EPIC and all its stories are now finished and concluded. Please refer to the next EPIC for current and ongoing work.

### 1. Meshtastic Communication (Relay Device - `btcmesh-server.py`)

- [x] **Story 1.1: Initialize Meshtastic Interface (Relay Device - `btcmesh-server.py`)**
- [x] *   **As a** system operator,
- [x] *   **I want** the relay application (`btcmesh-server.py`) to initialize a connection to its Meshtastic device,
- [x] *   **So that** it can send and receive messages.
    - [x] *   **Scenario:** Application starts
        - [x] *   **Given** a Meshtastic device is connected (e.g., via serial, configurable via `.env` or auto-detect).
        - [x] *   **When** the relay application (`btcmesh-server.py`) starts.
        - [x] *   **Then** it successfully establishes a connection with the Meshtastic interface.
        - [x] *   **And** logs the successful initialization.
    *   _Note: Serial port is configurable via `MESHTASTIC_SERIAL_PORT` in `.env` file. Implemented `core/config_loader.py`._

- [x] **Story 1.2: Receive and Identify Transaction Chunks (Relay Device - `btcmesh-server.py`)**
- [x] *   **As a** relay system (`btcmesh-server.py`),
- [x] *   **I want** to listen for and identify incoming direct messages that are part of a chunked Bitcoin transaction,
- [x] *   **So that** I can process them for reassembly.
    - [x] *   **Scenario:** Incoming Meshtastic DM with transaction chunk prefix
        - [x] *   **Given** the Meshtastic interface is initialized and listening.
        - [x] *   **When** a direct message starting with "BTC_TX|" is received (and addressed to the server).
        - [x] *   **Then** the message is identified as a potential transaction chunk.
        - [x] *   **And** its payload and sender ID are captured for reassembly processing (payload stored in `TRX_CHUNK_BUFFER`).
        - [x] *   **And** the event is logged.
    - [x] *   **Scenario:** Incoming standard Meshtastic DM (non-transaction chunk)
        - [x] *   **Given** the Meshtastic interface is initialized and listening.
        - [x] *   **When** a direct message *not* starting with "BTC_TX|" is received (and addressed to the server).
        - [x] *   **Then** the message is processed according to standard Meshtastic DM handling (logged as standard DM).
    - [x] *   **Scenario:** Non-text message received
        - [x] *   **Given** the Meshtastic interface is listening.
        - [x] *   **When** a non-text message (e.g., position update) is received as a DM to the server.
        - [x] *   **Then** the message is logged as an irrelevant DM type and ignored for transaction processing.
    *   _Note: Implemented `on_receive_text_message` callback and `TRX_CHUNK_BUFFER` placeholder. Server now only processes direct messages addressed to it._

- [x] **Story 1.3: Send Reply via DM (Relay Device - `btcmesh-server.py`)**
- [x] *   **As a** relay system (`btcmesh-server.py`),
- [x] *   **I want** to send a reply message to the original sender via Meshtastic DM,
- [x] *   **So that** the user (via `btcmesh-cli.py` or directly) receives feedback on their transaction submission.
    - [x] *   **Scenario:** Sending a success message after broadcast
        - [x] *   **Given** a `tx_session_id` from a successfully reassembled and broadcasted transaction, the original sender ID, and the Bitcoin transaction TXID.
        - [x] *   **When** the system needs to send feedback.
        - [x] *   **Then** a direct message "BTC_ACK|<tx_session_id>|SUCCESS|TXID:[actual_txid]" is sent to the sender ID.
        - [x] *   **And** the sent message is logged.
    - [x] *   **Scenario:** Sending an error message (e.g., reassembly failed, validation failed, RPC error)
        - [x] *   **Given** a `tx_session_id` (if available), sender ID, and a specific error message string.
        - [x] *   **When** the system needs to send error feedback.
        - [x] *   **Then** a direct message "BTC_NACK|<tx_session_id>|ERROR|[error_details]" is sent to the sender ID.
        - [x] *   **And** the sent message is logged.
    *   _Note: Implemented `send_meshtastic_reply(iface, destination_id, message_text, tx_session_id)` in `btcmesh_server.py`. Unit tests cover successful sends, various error conditions (invalid destination, node not found, send exceptions), and logging. Actual invocation points for replies will be added in subsequent stories (transaction processing, RPC interaction)._

### 2. Transaction Payload Handling (Relay Device - `btcmesh-server.py`)

- [x] **Story 2.1: Reassemble Chunked Transaction Hex**
    - [x] *   **As a** relay system (`btcmesh-server.py`),
    - [x] *   **I want** to reassemble the complete raw Bitcoin transaction hex string from incoming chunks,
    - [x] *   **So that** it can be decoded and validated.
        - [x] *   **Scenario:** Receiving all chunks for a transaction in order
        - [x] *   **Scenario:** Receiving chunks out of order
        - [x] *   **Scenario:** Timeout waiting for missing chunks
        - [x] *   **Scenario:** Receiving a duplicate chunk
        - [x] *   **Scenario:** Mismatched `total_chunks` for the same `tx_session_id`
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_server.py` (see `TestTransactionReassemblerStory21`)._

- [x] **Story 2.2: Validate Reassembled Hexadecimal String**
    - [x] *   **As a** relay system (`btcmesh-server.py`),
    - [x] *   **I want** to validate that the reassembled payload is a valid hexadecimal string,
    - [x] *   **So that** I don't try to decode invalid data.
        - [x] *   **Scenario:** Reassembled payload is valid hex
        - [x] *   **Scenario:** Reassembled payload contains non-hex characters
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_server.py` (see `TestHexValidationStory22`)._

- [x] **Story 2.3: Decode Reassembled Raw Bitcoin Transaction Hex**
    - [x] *   **As a** relay system (`btcmesh-server.py`),
    - [x] *   **I want** to decode the reassembled and validated hexadecimal string into its constituent Bitcoin transaction fields,
    - [x] *   **So that** basic structural validation can be performed.
        - [x] *   **Scenario:** Valid reassembled hex string representing a simple P2PKH transaction
        - [x] *   **Scenario:** Malformed or incomplete reassembled hex string
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_server.py` (see `TestTransactionDecodeStory23`)._

### 3. Basic Transaction Validation (Relay Device - `btcmesh-server.py`)

- [x] **Story 3.1: Perform Basic Sanity Checks on Decoded Transaction**
    - [x] *   **As a** relay system (`btcmesh-server.py`),
    - [x] *   **I want** to perform basic sanity checks on the decoded transaction structure (from reassembled data),
    - [x] *   **So that** obviously invalid transactions are not relayed.
        - [x] *   **Scenario:** Decoded transaction with no inputs
        - [x] *   **Scenario:** Decoded transaction with no outputs
        - [x] *   **Scenario:** Decoded transaction with valid structure
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_server.py` (see `TestTransactionSanityChecksStory31`)._

### 4. Bitcoin RPC Communication (Relay Device - `btcmesh-server.py`)
    (Stories 4.1, 4.2, 4.3 remain largely the same but operate on data validated from reassembled chunks)

- [x] **Story 4.1: Configure Bitcoin RPC Connection Details**
    - [x] *   **As a** relay system (`btcmesh-server.py`),
    - [x] *   **I want** to load Bitcoin Core RPC connection details from .env,
    - [x] *   **So that** the relay can connect to the Bitcoin node securely and flexibly.
        - [x] *   **Scenario:** Config present in .env
        - [x] *   **Scenario:** Missing/partial config in .env
        - [x] *   **Scenario:** Invalid config in .env
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_server.py` (see `TestBitcoinRpcConfigStory41`)._

- [x] **Story 4.2: Connect to Bitcoin RPC**
    - [x] *   **As a** relay system (`btcmesh-server.py`),
    - [x] *   **I want** to connect to the Bitcoin Core node's RPC interface using the loaded config,
    - [x] *   **So that** I can prepare to broadcast transactions.
        - [x] *   **Scenario:** Valid config, node reachable
        - [x] *   **Scenario:** Invalid config or node unreachable
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_server.py` (see `TestBitcoinRpcConnectionStory42`)._

- [x] **Story 4.3: Broadcast Transaction via RPC `sendrawtransaction`** (Input is the reassembled, validated hex)
    - [x] Server now broadcasts transactions via Bitcoin Core RPC after successful reassembly and validation.
    - [x] Sends ACK with TXID on success, NACK with error message on failure, to the original sender.

### 5. Logging and Configuration (Relay Device - `btcmesh-server.py`)
    (Stories 5.1, 5.2 remain largely the same)

- [x] **Story 5.1: Implement Local Logging** (Ensure logging covers chunking/reassembly)
- [x] **Story 5.2: Manage Configuration File** (May need a parameter for reassembly timeout)
    - [x] Server loads reassembly timeout from config (.env or environment).
    - [x] Logs the loaded value and its source (env/default) at startup.
    - [x] TransactionReassembler is initialized with the configured timeout.
    - [x] All logging/config stories for the relay are now complete.

### 6. `btcmesh-cli.py` Client Sender Script

- [x] **Story 6.1: Parse Command-Line Arguments (`btcmesh-cli.py`)**
    - [x] btcmesh-cli.py parses -d/--destination and -tx/--tx arguments.
    - [x] Validates raw tx hex (even length, hex chars).
    - [x] Handles missing/invalid input with usage or error message.
    - [x] Supports --dry-run for testable output.
    - [x] Ready for chunking/sending logic (Story 6.3).

- [x] **Story 6.2: Initialize Meshtastic Interface (`btcmesh-cli.py`)**
    - [x] CLI initializes Meshtastic interface (auto-detect or config port).
    - [x] Logs all connection attempts and errors to stdout and CLI log file.
    - [x] Handles device not found, import error, and exits with clear message.
    - [x] All TDD/BDD scenarios covered by tests and implementation.

- [x] **Story 6.3: Chunk Transaction and Send via Meshtastic (`btcmesh-cli.py`)**
    - [x] CLI segments, formats, and sends all transaction chunks via Meshtastic.
    - [x] Prints and logs confirmation for each chunk and final message.
    - [x] Handles and logs errors on sendText failure, aborts as needed.
    - [x] All TDD/BDD scenarios for multi-chunk, single-chunk, error, and logging are covered and passing.

- [x] **Story 6.4: Listen for Acknowledgement (`btcmesh-cli.py`) (Optional Enhancement)**
- [x] *   **As a** user of `btcmesh-cli.py`,
- [x] *   **I want** the script to listen for a confirmation message from the relay,
- [x] *   **So that** I know if the transaction was successfully processed or if an error occurred.
    - [x] *   **Scenario:** Relay sends SUCCESS acknowledgement
        - [x] *   **Given** `btcmesh-cli.py` has sent all chunks for `tx_session_id`.
        - [x] *   **When** a message "BTC_ACK|<tx_session_id>|SUCCESS|TXID:[actual_txid]" is received from the relay.
        - [x] *   **Then** `btcmesh-cli.py` prints "Transaction successfully broadcast by relay. TXID: [actual_txid]" and exits.
    - [x] *   **Scenario:** Relay sends ERROR acknowledgement
        - [x] *   **Given** `btcmesh-cli.py` has sent all chunks for `tx_session_id`.
        - [x] *   **When** a message "BTC_NACK|<tx_session_id>|ERROR|[error_details]" is received from the relay.
        - [x] *   **Then** `btcmesh-cli.py` prints "Relay reported an error: [error_details]" and exits.
    - [x] *   **Scenario:** Timeout waiting for acknowledgement
        - [x] *   **Given** `btcmesh-cli.py` has sent all chunks.
        - [x] *   **And** no BTC_ACK/BTC_NACK is received within a timeout period (e.g., 2 minutes).
        - [x] *   **When** the timeout occurs.
        - [x] *   **Then** `btcmesh-cli.py` prints "No acknowledgement received from relay for session <tx_session_id>" and exits.

- [x] **Story 6.5: Dry Run Without Meshtastic Connection (`btcmesh-cli.py`)**
- [x] *   **As a** user of `btcmesh-cli.py`,
- [x] *   **I want** dry run mode to work without a Meshtastic device connected,
- [x] *   **So that** I can test and validate transaction chunking logic without hardware.
    - [x] *   **Scenario:** Dry run executes without Meshtastic device
        - [x] *   **Given** no Meshtastic device is connected.
        - [x] *   **And** the user runs `btcmesh-cli.py` with `--dry-run` flag.
        - [x] *   **When** the CLI executes.
        - [x] *   **Then** the CLI skips Meshtastic interface initialization.
        - [x] *   **And** simulates transaction chunking and sending.
        - [x] *   **And** prints simulated chunk messages to stdout.
        - [x] *   **And** exits successfully without errors.

- [ ] **Story 6.6: Transaction History Persistence (`btcmesh-cli.py`)**
- [ ] *   **As a** user of `btcmesh-cli.py`,
- [ ] *   **I want** my sent transactions to be saved to a local history file,
- [ ] *   **So that** I can review past transactions across sessions.
    - [ ] *   **Scenario:** Transaction is logged after successful broadcast
        - [ ] *   **Given** a transaction is successfully broadcast.
        - [ ] *   **When** the SUCCESS ACK with TXID is received.
        - [ ] *   **Then** the transaction is saved to a local history file (e.g., `~/.btcmesh/history.json`).
        - [ ] *   **And** the history entry includes: timestamp, TXID, destination, raw tx hex, and status.
    - [ ] *   **Scenario:** Transaction is logged after failure
        - [ ] *   **Given** a transaction broadcast fails.
        - [ ] *   **When** the NACK or error is received.
        - [ ] *   **Then** the transaction is saved with status "failed" and error details.
    - [ ] *   **Scenario:** History persists across sessions
        - [ ] *   **Given** the user has sent transactions in previous sessions.
        - [ ] *   **When** the CLI runs again.
        - [ ] *   **Then** previous history entries are preserved.
        - [ ] *   **And** new entries are appended to existing history.

### 7. End-to-End Flow (With Chunking)

- [x] **Story 7.1: Successful End-to-End Transaction Relay (Chunked)**
- [x] *   **As a** user,
- [x] *   **I want** to use `btcmesh-cli.py` to send a valid raw Bitcoin transaction hex,
- [x] *   **So that** it gets chunked, sent, reassembled by the relay, broadcasted to the Bitcoin network, and I receive a confirmation with the TXID via `btcmesh-cli.py`.
    - [x] *   **Scenario:** User runs `btcmesh-cli.py` with a valid raw tx
        - [x] *   **Given** the relay device (`btcmesh-server.py`) is running and configured correctly.
        - [x] *   **And** the user has `btcmesh-cli.py` and a valid raw Bitcoin transaction hex.
        - [x] *   **When** the user executes `btcmesh-cli.py -d <relay_node_id> -tx <raw_tx_hex>`.
        - [x] *   **Then** `btcmesh-cli.py` connects to its Meshtastic device.
        - [x] *   **And** generates a `tx_session_id`.
        - [x] *   **And** chunks the transaction hex and sends each chunk (e.g., `BTC_TX|sess123|1/2|...`, `BTC_TX|sess123|2/2|...`) to the relay.
        - [x] *   **And** the relay device (`btcmesh-server.py`) receives these chunks.
        - [x] *   **And** the relay reassembles the complete hex string for `sess123` successfully.
        - [x] *   **And** the relay decodes the hex string successfully.
        - [x] *   **And** the relay validates the transaction structure successfully.
        - [x] *   **And** the relay connects to the Bitcoin RPC node.
        - [x] *   **And** the relay broadcasts the transaction successfully using `sendrawtransaction`.
        - [x] *   **And** the relay receives a TXID from the RPC node.
        - [x] *   **And** the relay sends a DM "BTC_ACK|sess123|SUCCESS|TXID:[actual_txid]" back to the `btcmesh-cli.py` sender's node ID.
        - [x] *   **And** (if Story 6.4 implemented) `btcmesh-cli.py` receives this ACK and prints the success message with TXID.
        - [x] *   **And** all relevant steps are logged by both `btcmesh-cli.py` and the relay device (`btcmesh-server.py`)

---

# EPIC: BTCMesh GUI Client Application

**Goal:** To provide users with a graphical interface for sending Bitcoin transactions via Meshtastic LoRa relay, wrapping the existing `btcmesh_cli.py` functionality in a user-friendly Kivy-based GUI with real-time feedback, connection status, and transaction controls.

**User Persona:** A Bitcoin user who prefers a graphical interface over command-line tools, wants visual feedback on transaction progress, and needs an intuitive way to send transactions via Meshtastic LoRa mesh network.

---

## Stories

> **Note:** This EPIC is still in development

### 8. GUI Application Framework (`btcmesh_gui.py`)

- [x] **Story 8.1: Create GUI Application Structure**
- [x] *   **As a** user,
- [x] *   **I want** a graphical application window with proper theming,
- [x] *   **So that** I can interact with BTCMesh visually.
    - [x] *   **Scenario:** Application launches with themed window
        - [x] *   **Given** the user runs `btcmesh_gui.py`.
        - [x] *   **When** the application starts.
        - [x] *   **Then** a GUI window opens with Bitcoin-orange themed colors.
        - [x] *   **And** the window has a dark background (#1E1E1E) for readability.
        - [x] *   **And** the window title is "BTCMesh Client".
    *   _Note: Implemented using Kivy App class with custom color scheme (COLOR_PRIMARY=#FF6B00, COLOR_SECUNDARY=#FFFFFF, COLOR_BG=#1E1E1E, COLOR_BG_LIGHT=#2D2D2D)._

- [x] **Story 8.2: Implement Input Fields for Transaction Data**
- [x] *   **As a** user,
- [x] *   **I want** text input fields for destination node ID and transaction hex,
- [x] *   **So that** I can enter the required data for sending a transaction.
    - [x] *   **Scenario:** User enters destination and transaction hex
        - [x] *   **Given** the GUI is running.
        - [x] *   **When** the user types in the destination field.
        - [x] *   **Then** the input is captured with placeholder hint "!node_id".
        - [x] *   **And** the transaction hex field accepts multiline input with hint "Raw transaction hex".
    *   _Note: Implemented TextInput widgets with hint_text, proper sizing, and dark theme styling._

- [x] **Story 8.3: Add Dry Run Toggle Control**
- [x] *   **As a** user,
- [x] *   **I want** a toggle to enable/disable dry run mode,
- [x] *   **So that** I can test transaction sending without actually broadcasting.
    - [x] *   **Scenario:** User enables dry run mode
        - [x] *   **Given** the GUI is running.
        - [x] *   **When** the user toggles the dry run button to "ON".
        - [x] *   **Then** the button displays "Dry Run: ON" with orange background.
        - [x] *   **And** subsequent sends will use --dry-run flag.
    - [x] *   **Scenario:** User disables dry run mode
        - [x] *   **Given** dry run mode is enabled.
        - [x] *   **When** the user toggles the button to "OFF".
        - [x] *   **Then** the button displays "Dry Run: OFF" with dark background.
        - [x] *   **And** subsequent sends will broadcast for real.
    *   _Note: Implemented using ToggleButton with state-dependent text and background color. Dry run without Meshtastic connection is handled by Story 6.5 in the CLI._

### 9. GUI Action Buttons and Controls

- [x] **Story 9.1: Implement Send Transaction Button**
- [x] *   **As a** user,
- [x] *   **I want** a Send button that initiates transaction sending,
- [x] *   **So that** I can broadcast my transaction with a single click.
    - [x] *   **Scenario:** User clicks Send with valid inputs
        - [x] *   **Given** destination and transaction hex are entered.
        - [x] *   **And** Meshtastic is connected.
        - [x] *   **When** the user clicks "Send".
        - [x] *   **Then** the button becomes disabled during sending.
        - [x] *   **And** the transaction is sent via `cli_main()` in a background thread.
        - [x] *   **And** progress is displayed in the status log.
    - [x] *   **Scenario:** User clicks Send with invalid inputs
        - [x] *   **Given** destination is empty or invalid.
        - [x] *   **When** the user clicks "Send".
        - [x] *   **Then** an error message is displayed in the status log.
        - [x] *   **And** the send is not initiated.
    *   _Note: Implemented `on_send_pressed()` with input validation via `validate_send_inputs()` pure function._
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_gui.py` (see `TestSendButtonValidationStory91`)._

- [x] **Story 9.2: Implement Load Example Button**
- [x] *   **As a** user,
- [x] *   **I want** a button to load example transaction data,
- [x] *   **So that** I can quickly test the application without manual input.
    - [x] *   **Scenario:** User clicks Load Example
        - [x] *   **Given** the GUI is running.
        - [x] *   **When** the user clicks "Load Example".
        - [x] *   **Then** the destination field is populated with "!abcd1234".
        - [x] *   **And** the transaction hex field is populated with EXAMPLE_RAW_TX.
        - [x] *   **And** a confirmation message appears in the status log.
    *   _Note: Implemented `on_load_example()` loading from `btcmesh_cli.EXAMPLE_RAW_TX`._

- [x] **Story 9.3: Implement Abort Button**
- [x] *   **As a** user,
- [x] *   **I want** an Abort button to cancel a running transaction send,
- [x] *   **So that** I can stop the process if needed.
    - [x] *   **Scenario:** User clicks Abort during active send
        - [x] *   **Given** a transaction send is in progress.
        - [x] *   **When** the user clicks "Abort".
        - [x] *   **Then** the abort_requested flag is set.
        - [x] *   **And** a warning message "Abort requested..." appears in the log.
        - [x] *   **And** the Abort button becomes disabled.
        - [x] *   **And** the send thread raises AbortedException on next stdout write.
        - [x] *   **And** the status log shows "Transaction aborted by user".
    - [x] *   **Scenario:** Abort button disabled when not sending
        - [x] *   **Given** no transaction send is in progress.
        - [x] *   **Then** the Abort button is disabled (grayed out).
    *   _Note: Implemented using `abort_requested` flag checked in PrintCapture.write(), raising AbortedException to interrupt cli_main()._
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_gui.py` (see `TestAbortButtonStory93`)._

- [x] **Story 9.4: Implement Clear Log Button**
- [x] *   **As a** user,
- [x] *   **I want** a Clear button to reset the status log,
- [x] *   **So that** I can start fresh without restarting the application.
    - [x] *   **Scenario:** User clicks Clear Log
        - [x] *   **Given** the status log contains messages.
        - [x] *   **When** the user clicks "Clear Log".
        - [x] *   **Then** all messages in the status log are cleared.
        - [x] *   **And** a "Log cleared" message is shown.
        - [x] *   **And** the input fields remain unchanged.
    *   _Note: Clear button positioned at bottom of window, only clears log (not inputs)._

### 10. Status Display and Feedback

- [x] **Story 10.1: Implement Connection Status Display**
- [x] *   **As a** user,
- [x] *   **I want** to see the Meshtastic connection status,
- [x] *   **So that** I know if the device is ready for sending.
    - [x] *   **Scenario:** Meshtastic connected successfully
        - [x] *   **Given** the GUI starts.
        - [x] *   **When** Meshtastic connection succeeds.
        - [x] *   **Then** the connection label shows "Meshtastic: Connected (!node_id)" in green.
    - [x] *   **Scenario:** Meshtastic connection failed
        - [x] *   **Given** the GUI starts.
        - [x] *   **When** Meshtastic connection fails.
        - [x] *   **Then** the connection label shows "Meshtastic: Connection failed" in red.
    *   _Note: Connection status updated via result queue from background init thread._
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_gui.py` (see `TestConnectionStatusStory101`)._

- [x] **Story 10.2: Implement Scrollable Status Log**
- [x] *   **As a** user,
- [x] *   **I want** a scrollable log area showing transaction progress,
- [x] *   **So that** I can see detailed feedback on what's happening.
    - [x] *   **Scenario:** Log messages appear during send
        - [x] *   **Given** a transaction send is in progress.
        - [x] *   **When** cli_main() logs or prints messages.
        - [x] *   **Then** messages appear in the scrollable status log.
        - [x] *   **And** ERROR messages appear in red (COLOR_ERROR).
        - [x] *   **And** WARNING messages appear in orange (COLOR_WARNING).
        - [x] *   **And** SUCCESS/ACK messages appear in green (COLOR_SUCCESS).
        - [x] *   **And** the log auto-scrolls to show newest messages.
    *   _Note: Implemented StatusLog widget with ScrollView, color-coded messages via `get_log_color()` and `get_print_color()` pure functions. Uses QueueLogHandler and ResultAction for thread-safe message passing from background threads to GUI._
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_gui.py` (see `TestStatusLogStory102`)._

- [x] **Story 10.3: Implement Success Popup**
- [x] *   **As a** user,
- [x] *   **I want** a clear popup notification when my transaction succeeds,
- [x] *   **So that** I immediately know my transaction was broadcast.
    - [x] *   **Scenario:** Transaction broadcast succeeds
        - [x] *   **Given** the relay returns a SUCCESS ACK with TXID.
        - [x] *   **When** the GUI processes the tx_success result.
        - [x] *   **Then** a success popup appears with "Transaction Sent!" and the TXID.
        - [x] *   **And** the popup has an OK button to dismiss.
    *   _Note: Implemented `_show_success_popup()` using Kivy Popup widget._
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_gui.py` (see `TestPopupsStory103`)._

- [x] **Story 10.4: Add Copy TXID to Clipboard Button**
- [x] *   **As a** user,
- [x] *   **I want** a button to copy the TXID to my clipboard,
- [x] *   **So that** I can easily paste it elsewhere to track or share my transaction.
    - [x] *   **Scenario:** User clicks Copy button
        - [x] *   **Given** the success popup is displayed with a TXID.
        - [x] *   **When** the user clicks the "Copy" button.
        - [x] *   **Then** the TXID is copied to the system clipboard.
        - [x] *   **And** the button text changes to "Copied!" briefly as feedback.
    *   _Note: Implemented using Kivy's Clipboard.copy() with visual feedback via Clock.schedule_once()._

### 11. Connection & Status Enhancements

- [x] **Story 11.1: Device Selection Dropdown**
- [x] *   **As a** user,
- [x] *   **I want** a dropdown to select from multiple connected Meshtastic devices,
- [x] *   **So that** I can choose which device to use for sending transactions.
    - [x] *   **Scenario:** Multiple devices available
        - [x] *   **Given** multiple Meshtastic devices are connected to the system.
        - [x] *   **When** the user opens the device dropdown.
        - [x] *   **Then** all available devices are listed with their serial ports.
        - [x] *   **And** the user can select a device to use.
    - [x] *   **Scenario:** Single device available
        - [x] *   **Given** only one Meshtastic device is connected.
        - [x] *   **When** the GUI starts.
        - [x] *   **Then** the device is automatically selected.
        - [x] *   **And** the dropdown shows the selected device.
    - [x] *   **Scenario:** No devices available
        - [x] *   **Given** no Meshtastic devices are connected.
        - [x] *   **When** the GUI starts.
        - [x] *   **Then** the dropdown shows "No devices found".
        - [x] *   **And** the Send button is disabled.

- [x] **Story 11.2: Known Nodes Dropdown for Destination**
- [x] *   **As a** user,
- [x] *   **I want** to select a destination from a list of known Meshtastic nodes,
- [x] *   **So that** I don't have to manually type the node ID.
    - [x] *   **Scenario:** Nodes available after connection
        - [x] *   **Given** the Meshtastic device is connected.
        - [x] *   **When** the node database has been populated.
        - [x] *   **Then** the destination dropdown shows known nodes formatted as "NodeName (!nodeId)".
        - [x] *   **And** selecting a node fills the destination field with the node ID.
    - [x] *   **Scenario:** No known nodes
        - [x] *   **Given** the Meshtastic device is connected.
        - [x] *   **When** the node database is empty.
        - [x] *   **Then** the dropdown shows "No nodes found".
        - [x] *   **And** the user can still manually type a destination.
    - [x] *   **Scenario:** Refresh node list
        - [x] *   **Given** the Meshtastic device is connected.
        - [x] *   **When** the user clicks the "Scan" button next to destination.
        - [x] *   **Then** the node list is updated from the current device node database.
    - [x] *   **Scenario:** Manual entry always available
        - [x] *   **Given** the destination dropdown shows known nodes.
        - [x] *   **When** the user selects "Enter manually..." from the dropdown.
        - [x] *   **Then** the destination input field is cleared for fresh entry.
        - [x] *   **And** the user can type any valid node ID in the destination field.
    - [x] *   **Scenario:** Cannot send to own node
        - [x] *   **Given** the user is connected to a Meshtastic device.
        - [x] *   **When** the user enters their own node ID as destination.
        - [x] *   **Then** an error message is shown: "Cannot send to your own node".
        - [x] *   **And** the transaction is not sent.
    *   _Implementation notes:_
    *   _Access nodes via `interface.nodes` dictionary after connection._
    *   _Each node has: `user.id`, `user.longName`, `user.shortName`, `lastHeard`, `hopsAway`._
    *   _Filter out own node (the connected device) from the list._
    *   _Sort nodes by `lastHeard` timestamp (most recent first)._
    *   _Format: "NodeName (!nodeId)"._

- [ ] **Story 11.3: Display Connected Device Name**
- [ ] *   **As a** user,
- [ ] *   **I want** to see the name of my connected Meshtastic device,
- [ ] *   **So that** I can identify which device I'm using at a glance.
    - [ ] *   **Scenario:** Device name shown in connection status
        - [ ] *   **Given** the Meshtastic device is connected.
        - [ ] *   **When** the device has a configured node name.
        - [ ] *   **Then** the connection status shows "Meshtastic: Connected - NodeName (!nodeId)".
    - [ ] *   **Scenario:** No device name configured
        - [ ] *   **Given** the Meshtastic device is connected.
        - [ ] *   **When** the device has no longName configured.
        - [ ] *   **Then** the connection status shows "Meshtastic: Connected (!nodeId)".
    *   _Implementation notes:_
    *   _Get own node info from `interface.nodes[own_node_id]` or `interface.getMyNodeInfo()`._
    *   _Extract `user.longName` or `user.shortName` as fallback._
    *   _Update connection label format in `process_result()` for 'connection_success'._

### 12. UX Improvements

- [ ] **Story 12.1: Client Settings Panel**
- [ ] *   **As a** client user,
- [ ] *   **I want** a settings panel to configure Meshtastic device and default options,
- [ ] *   **So that** I can customize the client without editing config files.
    - [ ] *   **Scenario:** User opens settings panel
        - [ ] *   **Given** the client GUI is running.
        - [ ] *   **When** the user clicks the "Settings" button.
        - [ ] *   **Then** a settings panel opens with client configuration options.
    - [ ] *   **Scenario:** User configures Meshtastic device path
        - [ ] *   **Given** the settings panel is open.
        - [ ] *   **When** the user enters a custom serial port path.
        - [ ] *   **Then** the setting is saved to the config file.
        - [ ] *   **And** the GUI reconnects using the new path.
    - [ ] *   **Scenario:** User sets default relay destination
        - [ ] *   **Given** the settings panel is open.
        - [ ] *   **When** the user enters a default relay node ID (e.g., !abcdef12).
        - [ ] *   **Then** the setting is saved.
        - [ ] *   **And** the destination field is pre-filled on next launch.

### 13. Convenience Features

- [ ] **Story 13.1: QR Code Scanner for Transaction Hex**
- [ ] *   **As a** user,
- [ ] *   **I want** to scan a QR code to input transaction hex,
- [ ] *   **So that** I can easily transfer transactions from another device.
    - [ ] *   **Scenario:** User scans QR code successfully
        - [ ] *   **Given** the GUI is running.
        - [ ] *   **When** the user clicks "Scan QR" and presents a QR code with transaction hex.
        - [ ] *   **Then** the camera opens and scans the QR code.
        - [ ] *   **And** the transaction hex field is populated with the scanned data.
        - [ ] *   **And** a confirmation message appears in the status log.
    - [ ] *   **Scenario:** QR code scan fails
        - [ ] *   **Given** the GUI is running.
        - [ ] *   **When** the QR code cannot be read or contains invalid data.
        - [ ] *   **Then** an error message is displayed.
        - [ ] *   **And** the transaction hex field remains unchanged.

- [ ] **Story 13.2: Paste from Clipboard Button**
- [ ] *   **As a** user,
- [ ] *   **I want** a button to paste transaction hex from my clipboard,
- [ ] *   **So that** I can quickly input copied transaction data.
    - [ ] *   **Scenario:** User pastes valid hex from clipboard
        - [ ] *   **Given** the clipboard contains valid transaction hex.
        - [ ] *   **When** the user clicks the "Paste" button.
        - [ ] *   **Then** the transaction hex field is populated with clipboard content.
        - [ ] *   **And** a confirmation message appears in the status log.
    - [ ] *   **Scenario:** Clipboard is empty or contains invalid data
        - [ ] *   **Given** the clipboard is empty or contains non-hex data.
        - [ ] *   **When** the user clicks the "Paste" button.
        - [ ] *   **Then** an appropriate message is displayed (empty or invalid).
        - [ ] *   **And** the transaction hex field remains unchanged.

- [ ] **Story 13.3: Transaction History UI**
- [ ] *   **As a** user,
- [ ] *   **I want** to view and interact with my transaction history in the GUI,
- [ ] *   **So that** I can review past transactions and quickly resend them.
    - [ ] *   **Scenario:** User views transaction history
        - [ ] *   **Given** the GUI is running and transaction history exists (from Story 6.6).
        - [ ] *   **When** the user opens the transaction history view.
        - [ ] *   **Then** past transactions are displayed in chronological order.
        - [ ] *   **And** each entry shows: truncated TXID, timestamp, destination, and status.
    - [ ] *   **Scenario:** User copies TXID from history
        - [ ] *   **Given** the transaction history view is open.
        - [ ] *   **When** the user clicks copy on a transaction entry.
        - [ ] *   **Then** the TXID is copied to the clipboard.
    - [ ] *   **Scenario:** User reloads a transaction for resending
        - [ ] *   **Given** the transaction history view is open.
        - [ ] *   **When** the user selects a transaction to reload.
        - [ ] *   **Then** the destination and transaction hex fields are populated.
        - [ ] *   **And** the user can modify and resend the transaction.
    *   _Note: Depends on Story 6.6 for persistence. GUI provides view/interaction layer._

### 14. Visual Enhancements

- [ ] **Story 14.1: Dark/Light Theme Toggle**
- [ ] *   **As a** user,
- [ ] *   **I want** to toggle between dark and light themes,
- [ ] *   **So that** I can use the application comfortably in different lighting conditions.
    - [ ] *   **Scenario:** User switches to light theme
        - [ ] *   **Given** the GUI is running in dark theme (default).
        - [ ] *   **When** the user clicks the theme toggle button.
        - [ ] *   **Then** the application switches to light theme.
        - [ ] *   **And** background becomes light, text becomes dark.
        - [ ] *   **And** the preference is saved for future sessions.
    - [ ] *   **Scenario:** User switches to dark theme
        - [ ] *   **Given** the GUI is running in light theme.
        - [ ] *   **When** the user clicks the theme toggle button.
        - [ ] *   **Then** the application switches to dark theme.
        - [ ] *   **And** the original dark color scheme is restored.

---

